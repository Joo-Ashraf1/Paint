import * as i0 from '@angular/core';
import { contentChildren, model, effect, output, inject, ElementRef, Component, input } from '@angular/core';
import Konva from 'konva';
import { Group } from 'konva/lib/Group';
import { Layer } from 'konva/lib/Layer';
import { Shape } from 'konva/lib/Shape';
import { Sprite } from 'konva/lib/shapes/Sprite';
import { Stage } from 'konva/lib/Stage';

// adapted FROM: https://github.com/lavrton/react-konva/blob/master/src/react-konva-fiber.js
function updatePicture(node) {
    const drawingNode = node.getLayer() || node.getStage();
    if (drawingNode) {
        drawingNode.batchDraw();
    }
}

// adapted FROM: https://github.com/lavrton/react-konva/blob/master/src/react-konva-fiber.js
function applyNodeProps(component, props = {}, oldProps = {}) {
    if ('id' in props) {
        const message = `ng2-konva: You are using "id" attribute for Konva node. In some very rare cases it may produce bugs. Currently we recommend not to use it and use "name" attribute instead.`;
        console.warn(message);
    }
    const instance = component.getStage();
    const updatedProps = {};
    let hasUpdates = false;
    Object.keys(oldProps).forEach((key) => {
        const isEvent = key.slice(0, 2) === 'on';
        const propChanged = oldProps[key] !== props[key];
        if (isEvent && propChanged) {
            let eventName = key.slice(2).toLowerCase();
            if (eventName.slice(0, 7) === 'content') {
                eventName =
                    'content' + eventName.slice(7, 8).toUpperCase() + eventName.slice(8);
            }
            instance.off(eventName, oldProps[key]);
        }
        const toRemove = !Object.hasOwn(props, key);
        if (toRemove) {
            instance.setAttr(key, undefined);
        }
    });
    Object.keys(props).forEach((key) => {
        const isEvent = key.slice(0, 2) === 'on';
        const toAdd = oldProps[key] !== props[key];
        if (isEvent && toAdd) {
            let eventName = key.slice(2).toLowerCase();
            if (eventName.slice(0, 7) === 'content') {
                eventName =
                    'content' + eventName.slice(7, 8).toUpperCase() + eventName.slice(8);
            }
            if (props[key]) {
                instance.off(eventName);
                instance.on(eventName, (event) => {
                    props[key]({
                        angularComponent: component,
                        event,
                    });
                });
            }
        }
        if (!isEvent &&
            (props[key] !== oldProps[key] || props[key] !== instance.getAttr(key))) {
            hasUpdates = true;
            updatedProps[key] = props[key];
        }
    });
    if (hasUpdates) {
        instance.setAttrs(updatedProps);
        updatePicture(instance);
        let val;
        Object.keys(updatedProps).forEach((prop) => {
            val = updatedProps[prop];
            if (val instanceof Image && !val.complete) {
                const node = instance;
                val.addEventListener('load', function () {
                    const layer = node.getLayer();
                    if (layer) {
                        layer.batchDraw();
                    }
                });
            }
        });
    }
}

function camelize(str) {
    return str
        .replace(/^\w|[A-Z]|\b\w/g, function (letter, index) {
        return index == 0 ? letter.toLowerCase() : letter.toUpperCase();
    })
        .replace(/\s+/g, '');
}
function capitalizeFirstLetter(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
}
function getName(componentTag) {
    return capitalizeFirstLetter(camelize(componentTag.slice(3).replace('-', ' ')));
}
function createListener(instance) {
    const output = {};
    [
        'mouseover',
        'mousemove',
        'mouseout',
        'mouseenter',
        'mouseleave',
        'mousedown',
        'mouseup',
        'wheel',
        'contextmenu',
        'click',
        'dblclick',
        'touchstart',
        'touchmove',
        'touchend',
        'tap',
        'dbltap',
        'dragstart',
        'dragmove',
        'dragend',
        'transformstart',
        'transform',
        'transformend',
    ].forEach((eventName) => {
        const name = eventName;
        const outputEmitter = instance[name];
        if (outputEmitter['listeners']?.length > 0) {
            output['on' + eventName] = outputEmitter.emit.bind(outputEmitter);
        }
    });
    return output;
}

/* eslint-disable @angular-eslint/no-output-native */
class CoreShapeComponent {
    shapes = contentChildren(CoreShapeComponent, ...(ngDevMode ? [{ debugName: "shapes" }] : []));
    config = model(...(ngDevMode ? [undefined, { debugName: "config" }] : []));
    #onConfigChange = effect(() => {
        const config = this.config();
        if (!config)
            return;
        this.uploadKonva(config);
    }, ...(ngDevMode ? [{ debugName: "#onConfigChange" }] : []));
    mouseover = output();
    mousemove = output();
    mouseout = output();
    mouseenter = output();
    mouseleave = output();
    mousedown = output();
    mouseup = output();
    wheel = output();
    contextmenu = output();
    click = output();
    dblclick = output();
    touchstart = output();
    touchmove = output();
    touchend = output();
    tap = output();
    dbltap = output();
    dragstart = output();
    dragmove = output();
    dragend = output();
    transformstart = output();
    transform = output();
    transformend = output();
    nameNode = getName(inject(ElementRef).nativeElement.localName);
    cacheProps = {};
    _stage;
    getStage() {
        return this._stage;
    }
    getNode() {
        return this._stage;
    }
    getConfig() {
        return this.config() || {};
    }
    constructor() {
        this.initKonva();
    }
    initKonva() {
        if (!this._stage) {
            this._stage = new Shape();
        }
        if (this.nameNode === 'Shape') {
            this._stage = new Shape();
        }
        else if (this.nameNode === 'Sprite') {
            this._stage = new Sprite(this.config());
        }
        else {
            this._stage = new Konva[this.nameNode](undefined);
        }
        const animationStage = this._stage.to.bind(this._stage);
        this._stage.to = (newConfig) => {
            animationStage(newConfig);
            setTimeout(() => {
                Object.keys(this._stage.attrs).forEach((key) => {
                    if (typeof this._stage.attrs[key] !== 'function' && this.config()) {
                        this.config.update((config) => ({
                            ...config,
                            [key]: this._stage.attrs[key],
                        }));
                    }
                });
            }, 200);
        };
        const config = this.config();
        if (config) {
            this.uploadKonva(config);
        }
    }
    uploadKonva(config) {
        if (!this._stage)
            return;
        const props = {
            ...config,
            ...createListener(this),
        };
        applyNodeProps(this, props, this.cacheProps);
        this.cacheProps = props;
    }
    #onShapesChange = effect(() => {
        this.shapes().forEach((item, index) => {
            if (this !== item) {
                if (this._stage instanceof Group || this._stage instanceof Layer) {
                    this._stage.add(item.getStage());
                }
                item.getStage().zIndex(index);
                updatePicture(this._stage);
            }
        });
    }, ...(ngDevMode ? [{ debugName: "#onShapesChange" }] : []));
    ngOnDestroy() {
        this._stage.destroy();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.7", ngImport: i0, type: CoreShapeComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.2.0", version: "20.3.7", type: CoreShapeComponent, isStandalone: true, selector: "ko-shape, ko-layer, ko-circle, ko-fastlayer, ko-group, ko-label, ko-rect, ko-ellipse, ko-wedge, ko-line, ko-sprite, ko-image, ko-text, ko-text-path, ko-star, ko-ring, ko-arc, ko-tag, ko-path, ko-regular-polygon, ko-arrow, ko-transformer", inputs: { config: { classPropertyName: "config", publicName: "config", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { config: "configChange", mouseover: "mouseover", mousemove: "mousemove", mouseout: "mouseout", mouseenter: "mouseenter", mouseleave: "mouseleave", mousedown: "mousedown", mouseup: "mouseup", wheel: "wheel", contextmenu: "contextmenu", click: "click", dblclick: "dblclick", touchstart: "touchstart", touchmove: "touchmove", touchend: "touchend", tap: "tap", dbltap: "dbltap", dragstart: "dragstart", dragmove: "dragmove", dragend: "dragend", transformstart: "transformstart", transform: "transform", transformend: "transformend" }, queries: [{ propertyName: "shapes", predicate: CoreShapeComponent, isSignal: true }], ngImport: i0, template: `<div><ng-content></ng-content></div>`, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.7", ngImport: i0, type: CoreShapeComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'ko-shape, ko-layer, ko-circle, ko-fastlayer, ko-group, ko-label, ko-rect, ko-ellipse, ko-wedge, ko-line, ko-sprite, ko-image, ko-text, ko-text-path, ko-star, ko-ring, ko-arc, ko-tag, ko-path, ko-regular-polygon, ko-arrow, ko-transformer',
                    template: `<div><ng-content></ng-content></div>`,
                }]
        }], ctorParameters: () => [], propDecorators: { shapes: [{ type: i0.ContentChildren, args: [i0.forwardRef(() => CoreShapeComponent), { isSignal: true }] }], config: [{ type: i0.Input, args: [{ isSignal: true, alias: "config", required: false }] }, { type: i0.Output, args: ["configChange"] }], mouseover: [{ type: i0.Output, args: ["mouseover"] }], mousemove: [{ type: i0.Output, args: ["mousemove"] }], mouseout: [{ type: i0.Output, args: ["mouseout"] }], mouseenter: [{ type: i0.Output, args: ["mouseenter"] }], mouseleave: [{ type: i0.Output, args: ["mouseleave"] }], mousedown: [{ type: i0.Output, args: ["mousedown"] }], mouseup: [{ type: i0.Output, args: ["mouseup"] }], wheel: [{ type: i0.Output, args: ["wheel"] }], contextmenu: [{ type: i0.Output, args: ["contextmenu"] }], click: [{ type: i0.Output, args: ["click"] }], dblclick: [{ type: i0.Output, args: ["dblclick"] }], touchstart: [{ type: i0.Output, args: ["touchstart"] }], touchmove: [{ type: i0.Output, args: ["touchmove"] }], touchend: [{ type: i0.Output, args: ["touchend"] }], tap: [{ type: i0.Output, args: ["tap"] }], dbltap: [{ type: i0.Output, args: ["dbltap"] }], dragstart: [{ type: i0.Output, args: ["dragstart"] }], dragmove: [{ type: i0.Output, args: ["dragmove"] }], dragend: [{ type: i0.Output, args: ["dragend"] }], transformstart: [{ type: i0.Output, args: ["transformstart"] }], transform: [{ type: i0.Output, args: ["transform"] }], transformend: [{ type: i0.Output, args: ["transformend"] }] } });

/* eslint-disable @angular-eslint/no-output-native */
class StageComponent {
    nodeContainer = inject(ElementRef).nativeElement;
    shapes = contentChildren(CoreShapeComponent, ...(ngDevMode ? [{ debugName: "shapes" }] : []));
    config = input(...(ngDevMode ? [undefined, { debugName: "config" }] : []));
    #onConfigChange = effect(() => {
        const config = this.config();
        if (!config)
            return;
        if (!this._stage) {
            this._stage = new Stage({
                ...config,
                container: this.nodeContainer,
            });
            this.uploadKonva(config);
        }
        else {
            this.uploadKonva(config);
        }
    }, ...(ngDevMode ? [{ debugName: "#onConfigChange" }] : []));
    mouseover = output();
    mousemove = output();
    mouseout = output();
    mouseenter = output();
    mouseleave = output();
    mousedown = output();
    mouseup = output();
    wheel = output();
    contextmenu = output();
    click = output();
    dblclick = output();
    touchstart = output();
    touchmove = output();
    touchend = output();
    tap = output();
    dbltap = output();
    dragstart = output();
    dragmove = output();
    dragend = output();
    transformstart = output();
    transform = output();
    transformend = output();
    _stage;
    cacheProps = {};
    getStage() {
        return this._stage;
    }
    getNode() {
        return this._stage;
    }
    getConfig() {
        return this.config() || {};
    }
    uploadKonva(config) {
        const props = {
            ...config,
            ...createListener(this),
        };
        applyNodeProps(this, props, this.cacheProps);
        this.cacheProps = props;
    }
    #onShapesChange = effect(() => {
        this.shapes().forEach((item, index) => {
            if (!(item.getStage() instanceof Layer)) {
                throw 'You can only add Layer Nodes to Stage Nodes!';
            }
            this._stage.add(item.getStage());
            item.getStage().zIndex(index);
            updatePicture(this._stage);
        });
    }, ...(ngDevMode ? [{ debugName: "#onShapesChange" }] : []));
    ngOnDestroy() {
        this._stage.destroy();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.3.7", ngImport: i0, type: StageComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.2.0", version: "20.3.7", type: StageComponent, isStandalone: true, selector: "ko-stage", inputs: { config: { classPropertyName: "config", publicName: "config", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { mouseover: "mouseover", mousemove: "mousemove", mouseout: "mouseout", mouseenter: "mouseenter", mouseleave: "mouseleave", mousedown: "mousedown", mouseup: "mouseup", wheel: "wheel", contextmenu: "contextmenu", click: "click", dblclick: "dblclick", touchstart: "touchstart", touchmove: "touchmove", touchend: "touchend", tap: "tap", dbltap: "dbltap", dragstart: "dragstart", dragmove: "dragmove", dragend: "dragend", transformstart: "transformstart", transform: "transform", transformend: "transformend" }, queries: [{ propertyName: "shapes", predicate: CoreShapeComponent, isSignal: true }], ngImport: i0, template: `<div><ng-content></ng-content></div>`, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.7", ngImport: i0, type: StageComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'ko-stage',
                    template: `<div><ng-content></ng-content></div>`,
                }]
        }], propDecorators: { shapes: [{ type: i0.ContentChildren, args: [i0.forwardRef(() => CoreShapeComponent), { isSignal: true }] }], config: [{ type: i0.Input, args: [{ isSignal: true, alias: "config", required: false }] }], mouseover: [{ type: i0.Output, args: ["mouseover"] }], mousemove: [{ type: i0.Output, args: ["mousemove"] }], mouseout: [{ type: i0.Output, args: ["mouseout"] }], mouseenter: [{ type: i0.Output, args: ["mouseenter"] }], mouseleave: [{ type: i0.Output, args: ["mouseleave"] }], mousedown: [{ type: i0.Output, args: ["mousedown"] }], mouseup: [{ type: i0.Output, args: ["mouseup"] }], wheel: [{ type: i0.Output, args: ["wheel"] }], contextmenu: [{ type: i0.Output, args: ["contextmenu"] }], click: [{ type: i0.Output, args: ["click"] }], dblclick: [{ type: i0.Output, args: ["dblclick"] }], touchstart: [{ type: i0.Output, args: ["touchstart"] }], touchmove: [{ type: i0.Output, args: ["touchmove"] }], touchend: [{ type: i0.Output, args: ["touchend"] }], tap: [{ type: i0.Output, args: ["tap"] }], dbltap: [{ type: i0.Output, args: ["dbltap"] }], dragstart: [{ type: i0.Output, args: ["dragstart"] }], dragmove: [{ type: i0.Output, args: ["dragmove"] }], dragend: [{ type: i0.Output, args: ["dragend"] }], transformstart: [{ type: i0.Output, args: ["transformstart"] }], transform: [{ type: i0.Output, args: ["transform"] }], transformend: [{ type: i0.Output, args: ["transformend"] }] } });

class KonvaComponent extends Component {
    getStage;
    getNode;
    getConfig;
    config;
    mouseover;
    mousemove;
    mouseout;
    mouseenter;
    mouseleave;
    mousedown;
    mouseup;
    wheel;
    contextmenu;
    click;
    dblclick;
    touchstart;
    touchmove;
    touchend;
    tap;
    dbltap;
    dragstart;
    dragmove;
    dragend;
    transformstart;
    transform;
    transformend;
}

/*
 * Public API Surface of ng2-konva
 */

/**
 * Generated bundle index. Do not edit.
 */

export { CoreShapeComponent, KonvaComponent, StageComponent };
//# sourceMappingURL=ng2-konva.mjs.map
